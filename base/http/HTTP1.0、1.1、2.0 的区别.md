
# 一、HTTP1.0

`HTTP 1.0` 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个`TCP`连接，服务器完成请求处理后立即断开`TCP`连接。

简单来讲，`HTTP 1.0`是串行连接，即：每次与服务器交互，都需要新开一个连接。

![image](https://user-images.githubusercontent.com/74364990/174445021-09fee91c-27ae-416e-825f-13ba3ec75bc9.png)


# 二、HTTP1.1

HTTP 1.1 新增：

- 并行连接
- 长连接
- 管道化连接
- 新增了一些请求头和响应头（If-Unmodified-Since, If-Match, If-None-Match、range等）
- 新增了一些请求方法（put、delete、options）


<br>

## 1、并行连接

`HTTP 1.1`新增并行连接，即：一个客户端可以建立多个TCP连接，每个TCP连接上都能发起请求。

浏览同时发起多个http事务，因为是并行的，所以时延也并行的，这样总时延较小，页面呈现更快，体验较好。但也不是总是这样，因为如果在网络速度很慢的时候，多个连接会去竞争本来不多的带宽，那么就谈不上加快速度了。还有就是并行连接也是需要付出代价的，比如增加系统内训消耗、服务器负载，比如有一个100客户端同时对服务发起100tcp并行连接的话，那么服务器就得负责10000个处理请求，很快的你的服务器就会爆掉。当然了，并行连接确实能带来视觉上的速度提升，因为相比于串行连接慢慢地显示数据而并行一下子能全部显示完信息，视觉上并行连接会给人速度更快的感觉！

## 2、长连接

长连接，也叫`持久链接`。

HTTP 1.1中，默认支持长连接（`Connection: keep-alive`），即在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟

长连接描述的是：如果对`同ip、同端口`的发起多个http事务连接，那么可以在前一个事务处理完成之后不要关闭tcp连接，以此来减小建立tcp、tcp慢启动所带来的时延。

![image](https://user-images.githubusercontent.com/74364990/174446055-b244c179-08bf-4fe0-a88f-267e34e252c3.png)

![](https://imgconvert.csdnimg.cn/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0xYWU4Yzk1YWNiYjFiMzY0LmpwZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA)

## 3、管道化连接

在`长连接的基础上`，`HTTP 1.1`进一步地支持在持久连接上`使用管道化（pipelining）特性`，这是`相对于keep-alive连接的又一性能优化`。在相应到达之前，可以将多条请求放入队列，当第一条请求发往服务器的时候，第二第三条请求也可以开始发送了，不用等到第一条请求响应回来，在高延时网络条件下，这样做可以降低网络的环回时间，提高性能。


**缺点：**
虽然可以一次发送多个请求(发一个不用等响应就发下一个)。但HTTP1.1规定，`服务器端的响应的发送要根据请求被接收的顺序排队`，也就是说，先接收到的请求需要先响应回来。这样造成的问题是，如果最先收到的请求的处理时间长的话，响应生成也慢，就会阻塞已经生成了的响应的发送。

>务必读完：[HTTP详解长短连接，管道化，队头阻塞及它们之间的关系](https://blog.csdn.net/fesfsefgs/article/details/108294050)

**非管道化与管道化的区别示意：**

![image](https://user-images.githubusercontent.com/74364990/173564080-fa6c7a7b-1226-49e7-97bc-2f4e9d074ac7.png)


#### 总结下：串行链接（HTTP1.0）、长链接（HTTP1.1）、管道化连接（HTTP1.1）

![image](https://user-images.githubusercontent.com/74364990/173563201-cebc6100-589e-45d4-a56e-ce419da6c931.png)

<br>


# 三、HTTP2.0

而`HTTP 2.0`在相比之前版本，性能上有很大的提升，如添加了一个特性：

- 二进制分帧
- 多路复用
- 首部压缩
- 服务器推送

## 二进制分帧

帧是HTTP2.0通信中最小单位信息

HTTP2.0 `采用二进制格式传输数据`，而非 HTTP 1.x的文本格式，解析起来更高效

将请求和响应数据分割为更小的帧，并且它们采用二进制编码

HTTP2.0中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流

每个数据流都以消息的形式发送，而`消息`又由一个或`多个帧组成`。多个`帧之间可以乱序发送`，根据帧首部的流标识可以重新组装，这也是`多路复用`同时发送数据的实现条件

## 多路复用

HTTP2.0 中将多个请求复用同一个TCP通道中，`通过二进制分帧`并且`给每个帧`打上`流`的 `ID` 去避免依次响应的问题，对方接收到帧之后`根据 ID 拼接出流`，这样就可以做到乱序响应从而避免请求时的队首阻塞问题.

![image](https://user-images.githubusercontent.com/74364990/174446987-90125160-2c9d-400c-b5c7-a35f8b959c11.png)

上图中，可以看到第四步中css、js资源是同时发送到服务端


## 首部压缩

HTTP2.0在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送

首部表在HTTP2.0的连接存续期内始终存在，由客户端和服务器共同渐进地更新

例如：下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销

![image](https://user-images.githubusercontent.com/74364990/174447011-19fbc579-a91a-400a-a2f9-a75a30435076.png)

## 服务器推送

HTTP2.0引入服务器推送，允许服务端推送资源给客户端

服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源

免得客户端再次创建连接发送请求到服务器端获取

这种方式非常合适加载静态资源

![image](https://user-images.githubusercontent.com/74364990/174447022-d9071561-0176-4ff3-b00a-3c0e877cc440.png)


<br>

# 四、一些比较

## 多路复用(HTTP2.0) 和 长连接(HTTP1.1) 的区别

![image](https://user-images.githubusercontent.com/74364990/173565509-34493d2e-d5e7-4153-ba96-3fc919cd8a5b.png)

#### 共同点：

都可以复用同一条TCP通道

#### 不同点：

**1、http1.1中的keep-alive**

有顺序，有阻塞的请求

① 请求 a.html<br>
② 响应 a.html<br>
③ 请求 b.css<br>
④ 响应 b.css


**2、https多路复用**

并发请求，非阻塞的

详细描述：

keep-alive虽然可以复用同一条TCP通道，但必须等到服务端响应了前一次请求，才能发起第二次请求 -> 阻塞。 按顺序发送请求，按顺序接收请求，这样接收端才不会乱掉。从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间

```
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
```

http2 的多路复用可以在一条TCP通道同时发送多个请求，不一定要按照顺序，非阻塞的，先响应先回来，响应式时也不用等上一个请求先响应，这些请求都有唯一标识，所以可以无序。


