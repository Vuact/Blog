# 一、HTTP

HTTP (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范。

HTTP传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别，所以说HTTP不安全。

存在问题：

- 通信使用明文（不加密），内容可能被窃听
- 不验证通信方的身份，因此有可能遭遇伪装

## 1、HTTP 中间人攻击

HTTP 协议使用起来确实非常的方便，但是它存在一个致命的缺点：`不安全`。

我们知道 HTTP 协议中的报文都是以明文的方式进行传输，不做任何加密，这样会导致什么问题呢？下面来举个例子：

**（1）小明在 JAVA 贴吧发帖，内容为：`我爱JAVA`**

![image](https://user-images.githubusercontent.com/74364990/174847063-bf6238de-eeb9-47c1-a807-1410dad7a8ac.png)

**（2）被中间人进行攻击，内容修改为：`我爱PHP`**

![image](https://user-images.githubusercontent.com/74364990/174847167-42940751-916b-4573-a24e-70455f5733b7.png)

**（3）小明被群嘲(手动狗头)**

可以看到在 HTTP 传输过程中，中间人能看到并且修改 HTTP 通讯中所有的请求和响应内容，所以使用 HTTP 是非常的不安全的。

<br>

## 2、防止中间人攻击：对称加密

这个时候可能就有人想到了，既然内容是明文那我使用`对称加密`的方式将报文加密这样中间人不就看不到明文了吗，于是如下改造：

**（1）双方约定加密方式**

![image](https://user-images.githubusercontent.com/74364990/174847838-2845055c-f3e8-4814-84cc-078ba65c1c4c.png)

**（2）使用 AES 加密报文**

![image](https://user-images.githubusercontent.com/74364990/174847902-c0914452-af05-4fd5-bf49-19f77c0c9d1b.png)

这样看似中间人获取不到明文信息了，但其实在通讯过程中还是会以明文的方式暴露加密方式和秘钥，如果第一次通信被拦截到了，那么秘钥就会泄露给中间人，中间人仍然可以解密后续的通信：

![image](https://user-images.githubusercontent.com/74364990/174848003-a24438c7-c055-4183-ad8b-739eca9c5990.png)

那么对于这种情况，我们肯定就会考虑能不能将秘钥进行加密不让中间人看到呢？答案是有的，采用`非对称加密`，我们可以通过 RSA 算法来实现。

<br>

## 3、防止中间人攻击：对称加密 + 非对称加密 （HTTPS采用这种方式）

在约定加密方式的时候由服务器生成一对`公私钥`，服务器将`公钥`返回给客户端，客户端本地随机生成一串秘钥(`AES_KEY`)用于`对称加密`，并通过服务器发送的`公钥`进行加密得到(`AES_KEY_SECRET`)，之后返回给服务端，服务端通过`私钥`将客户端发送的`AES_KEY_SECRET`进行解密得到`AEK_KEY`,最后客户端和服务器通过`AEK_KEY`进行报文的加密通讯，改造如下：

>简单说就是：服务端发给客户端一个锁头(公钥)，客户端再将随机生成的钥匙(密钥)注入到锁头中锁住，然后再给服务端；服务端再将锁头打开得到那把钥匙(密钥)；这样两边就都有一个相同的开锁钥匙，就可以加密发送数据了。

![image](https://user-images.githubusercontent.com/74364990/174848381-1008abce-fc06-49a2-b4bb-041989d2cfa2.png)

可以看到这种情况下中间人是窃取不到用于`AES加密`的秘钥，所以对于后续的通讯是肯定无法进行解密了，那么这样做就是绝对安全了吗？

所谓道高一尺魔高一丈，中间人为了对应这种加密方法又想出了一个新的破解方案，既然拿不到`AES_KEY`，那我就把自己模拟成一个客户端和服务器端的结合体，`在用户->中间人`的过程中中间人模拟服务器的行为，这样可以拿到用户请求的明文，在`中间人->服务器`的过程中中间人模拟客户端行为，这样可以拿到服务器响应的明文，以此来进行中间人攻击：

![image](https://user-images.githubusercontent.com/74364990/174848744-c7cccefa-c181-488f-a15b-501540fdf44c.png)

这一次通信再次被中间人截获，中间人自己也伪造了一对公私钥，并将公钥发送给用户以此来窃取客户端生成的`AES_KEY`，在拿到`AES_KEY`之后就能轻松的进行解密了。

中间人这样为所欲为，就没有办法制裁下吗，当然有啊，接下来我们看看 HTTPS 是怎么解决通讯安全问题的。


<br><br>

# 二、HTTPS

`HTTPS`的出现正是解决上面`HTTP`的那些问题，`HTTPS`是建立在`SSL`之上，其安全性由`SSL`来保证

在采用`SSL`后，`HTTP`就拥有了`HTTPS`的加密、证书和完整性保护这些功能。

<image src="https://user-images.githubusercontent.com/74364990/174455143-86ee142d-59fa-4b1f-bfb3-8e6fbe24bd26.png" width="350px" height="200px"/>

>SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议

## 1、加密方式

HTTPS的加密方式：即 `对称加密 + 非对称加密`。

简单说就是：服务端发给客户端一个锁头(公钥)，客户端再将随机生成的钥匙(密钥)注入到锁头中锁住，然后再给服务端；服务端再将锁头打开得到那把钥匙(密钥)；这样两边就都有一个相同的开锁钥匙，就可以加密发送数据了。

但上面也说了，这种方式并不能避免 `中间人攻击`，也不能避免`发送内容遭篡改`的问题。接下来就交给`HTTPS`的 `数字签名` 和 `数字证书` 吧。

## 2、数字签名：解决报文遭篡改问题

网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？—-校验数字签名。


**数字签名如何生成:**

![image](https://user-images.githubusercontent.com/74364990/175810230-fa250cd4-360f-4165-84f4-9aa48c827333.png)

将一段文本先用Hash函数生成消息摘要，然后用发送者的`私钥`加密`生成数字签名`，与原文一起传送给接收者。接下来就是接收者校验数字签名的流程了。

**校验数字签名流程：**

![image](https://user-images.githubusercontent.com/74364990/175810252-8608bc95-964a-478a-8acc-1785c6f4caa0.png)

接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。

假设消息传递在Alice，Bob两人之间发生。Bob将消息连同数字签名一起发送给Alice，Alice接收到消息后，通过校验数字签名，就可以验证接收到的消息就是Bob发送的。当然，这个过程的`前提是Alice知道Bob的公钥`。问题的关键的是，和消息本身一样，`公钥不能在不安全的网络中直接发送`给Alice，或者说拿到的公钥如何证明是Bob的。

此时就需要引入了证书颁发机构（`Certificate Authority`，简称`CA`），`CA`数量并不多，Alice客户端内置了所有受信任`CA`的证书。`CA`对Bob的公钥（和其他信息）数字签名后生成证书。


## 3、数字证书：解决通信方身份可能被伪装的问题

`公钥`在数字签名技术里面扮演举足轻重的角色，但是如何保证公钥是合法的呢，如果是遭到中间人攻击，掉包怎么办？这个时候公钥就应该交给一个第三方权威机构来管理，这个机构就是认证机构（Certification Authority）CA，CA 把用户的姓名、组织、邮箱地址等个人信息收集起来，还有此人的公钥，并由 CA 提供数字签名生成公钥证书（Public-Key Certificate）PKC，简称证书。

![image](https://user-images.githubusercontent.com/74364990/175810435-955b8d89-9b82-4f64-b307-e94718652322.png)

Alice 向 Bob 发送消息时，是通过 Bob 提供的公钥加密后的数据，而 Alice 获取的公钥并不是由 Bob 直接给的，而是由委托一个受信任的第三方机构给的。

- （1）Bob 生成密钥对，私钥自己保管，公钥交给认证机构 Trent。
- （2）Trent 经过一系列严格的检查确认公钥是 Bob 本人的
- （3）Trent 事先也生成自己的一套密钥对，用自己的私钥对 Bob 的公钥进行数字签名并生成数字证书。证书中包含了 Bob 的公钥。公钥在这里是不需要加密的，因为任何人获取 Bob 的公钥都没事，只要确定是 Bob 的公钥就行。
- （4）Alice 获取 Trent 提供的证书。
- （5）Alice 用 Trent 提供的公钥对证书进行签名验证，签名验证成功就表示证书中的公钥是 Bob 的。
- （6）于是 Alice 就可以用 Bob 提供的公钥对消息加密后发送给 Bob。
- （7）Bob 收到密文后，用与之配对的私钥进行解密。

至此，一套比较完善的数据传输方案就完成了。HTTPS（SSL/TLS）就是在这样一套流程基础之上建立起来的。


# 三、HTTP 与 HTTPS的区别

![image](https://user-images.githubusercontent.com/74364990/174846397-f86ca6c8-cf54-474e-9c71-2b6319a1ad7a.png)


> 参考：https://segmentfault.com/a/1190000023936425
