# 一、HTTP

HTTP (HyperText Transfer Protocol)，即超文本运输协议，是实现网络通信的一种规范。

HTTP传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别，所以说HTTP不安全。

存在问题：

- 通信使用明文（不加密），内容可能被窃听
- 不验证通信方的身份，因此有可能遭遇伪装

## 1、HTTP 中间人攻击

HTTP 协议使用起来确实非常的方便，但是它存在一个致命的缺点：`不安全`。

我们知道 HTTP 协议中的报文都是以明文的方式进行传输，不做任何加密，这样会导致什么问题呢？下面来举个例子：

**（1）小明在 JAVA 贴吧发帖，内容为：`我爱JAVA`**

![image](https://user-images.githubusercontent.com/74364990/174847063-bf6238de-eeb9-47c1-a807-1410dad7a8ac.png)

**（2）被中间人进行攻击，内容修改为：`我爱PHP`**

![image](https://user-images.githubusercontent.com/74364990/174847167-42940751-916b-4573-a24e-70455f5733b7.png)

**（3）小明被群嘲(手动狗头)**

可以看到在 HTTP 传输过程中，中间人能看到并且修改 HTTP 通讯中所有的请求和响应内容，所以使用 HTTP 是非常的不安全的。

<br>

## 2、防止中间人攻击：对称加密

这个时候可能就有人想到了，既然内容是明文那我使用`对称加密`的方式将报文加密这样中间人不就看不到明文了吗，于是如下改造：

**（1）双方约定加密方式**

![image](https://user-images.githubusercontent.com/74364990/174847838-2845055c-f3e8-4814-84cc-078ba65c1c4c.png)

**（2）使用 AES 加密报文**

![image](https://user-images.githubusercontent.com/74364990/174847902-c0914452-af05-4fd5-bf49-19f77c0c9d1b.png)

这样看似中间人获取不到明文信息了，但其实在通讯过程中还是会以明文的方式暴露加密方式和秘钥，如果第一次通信被拦截到了，那么秘钥就会泄露给中间人，中间人仍然可以解密后续的通信：

![image](https://user-images.githubusercontent.com/74364990/174848003-a24438c7-c055-4183-ad8b-739eca9c5990.png)

那么对于这种情况，我们肯定就会考虑能不能将秘钥进行加密不让中间人看到呢？答案是有的，采用`非对称加密`，我们可以通过 RSA 算法来实现。

<br>

## 3、防止中间人攻击：对称加密 + 非对称加密 （HTTPS采用这种方式）

在约定加密方式的时候由服务器生成一对`公私钥`，服务器将`公钥`返回给客户端，客户端本地随机生成一串秘钥(`AES_KEY`)用于`对称加密`，并通过服务器发送的`公钥`进行加密得到(`AES_KEY_SECRET`)，之后返回给服务端，服务端通过`私钥`将客户端发送的`AES_KEY_SECRET`进行解密得到`AEK_KEY`,最后客户端和服务器通过`AEK_KEY`进行报文的加密通讯，改造如下：

>简单说就是：服务端发给客户端一个锁头(公钥)，客户端再将随机生成的钥匙(密钥)注入到锁头中锁住，然后再给服务端；服务端再将锁头打开得到那把钥匙(密钥)；这样两边就都有一个相同的开锁钥匙，就可以加密发送数据了。

![image](https://user-images.githubusercontent.com/74364990/174848381-1008abce-fc06-49a2-b4bb-041989d2cfa2.png)

可以看到这种情况下中间人是窃取不到用于`AES加密`的秘钥，所以对于后续的通讯是肯定无法进行解密了，那么这样做就是绝对安全了吗？

所谓道高一尺魔高一丈，中间人为了对应这种加密方法又想出了一个新的破解方案，既然拿不到`AES_KEY`，那我就把自己模拟成一个客户端和服务器端的结合体，`在用户->中间人`的过程中中间人模拟服务器的行为，这样可以拿到用户请求的明文，在`中间人->服务器`的过程中中间人模拟客户端行为，这样可以拿到服务器响应的明文，以此来进行中间人攻击：

![image](https://user-images.githubusercontent.com/74364990/174848744-c7cccefa-c181-488f-a15b-501540fdf44c.png)

这一次通信再次被中间人截获，中间人自己也伪造了一对公私钥，并将公钥发送给用户以此来窃取客户端生成的`AES_KEY`，在拿到`AES_KEY`之后就能轻松的进行解密了。

中间人这样为所欲为，就没有办法制裁下吗，当然有啊，接下来我们看看 HTTPS 是怎么解决通讯安全问题的。


<br><br>

# 二、HTTPS

`HTTPS`的出现正是解决上面`HTTP`的那些问题。

在HTTP的基础上再加一层TLS（传输层安全性协议）或者SSL（安全套接层），就构成了HTTPS协议。其安全性由`SSL`或`TLS`来保证。


<image src="https://user-images.githubusercontent.com/74364990/174455143-86ee142d-59fa-4b1f-bfb3-8e6fbe24bd26.png" width="350px" height="200px"/>

>SSL(Secure Sockets Layer 安全套接字协议),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议

## 1、加密方式

HTTPS的加密方式：即上面说的 `对称加密 + 非对称加密`。

简单说就是：服务端发给客户端一个锁头(公钥)，客户端再将随机生成的钥匙(密钥)注入到锁头中锁住，然后再给服务端；服务端再将锁头打开得到那把钥匙(密钥)；这样两边就都有一个相同的开锁钥匙，就可以加密发送数据了。

但上面也说了，这种方式并不能避免 `中间人攻击`，也不能避免`发送内容遭篡改`的问题。接下来就交给`HTTPS`的 `数字签名` 和 `数字证书` 吧。

## 2、数字签名：解决报文遭篡改问题

网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？—-校验数字签名。

拿Alice 向 Bob 发送消息举例：

**数字签名如何生成:**

![image](https://user-images.githubusercontent.com/74364990/175810230-fa250cd4-360f-4165-84f4-9aa48c827333.png)

Alice 先将消息 `用Hash函数生成消息摘要`，再用自己的`私钥`加密生成`数字签名`，然后再将这个签名附在消息下面，一起发给Bob。

接下来就是 Bob 校验数字签名的流程了。

**校验数字签名流程：**

![image](https://user-images.githubusercontent.com/74364990/175810252-8608bc95-964a-478a-8acc-1785c6f4caa0.png)

> 公钥和私钥通常有可以互相加解密的特性： 将原始信息用公钥加密后，可以使用私钥解密； 将原始信息用私钥加密后，通常可以使用公钥解密。 一般公钥是对所有人公开的，原始数据使用公钥加密后，只有拥有私钥的人才能解密。

Bob收到消息后，取下数字签名，再用Alice的公钥解密，得到消息的摘要。

Bob再对消息本身使用`Hash函数`产生一个`新的摘要信息`，再与上一步得到的`摘要进行对比`。如果两者一致，就证明这个消息未被修改过，因此数字签名能够验证信息的完整性

当然，上述过程的`前提是Bob知道Alice的公钥`。问题的关键和消息本身一样，`公钥不能在不安全的网络中直接发送`给Bob，或者说拿到的公钥如何证明是Alice的。

此时就需要引入了证书颁发机构（`Certificate Authority`，简称`CA`），`CA`数量并不多，Bob客户端内置了所有受信任`CA`的证书。`CA`对Alice的公钥（和其他信息）数字签名后生成证书。


## 3、数字证书：解决通信方身份可能被伪装的问题

`公钥`在数字签名技术里面扮演举足轻重的角色，但是如何保证公钥是合法的呢，如果是遭到中间人攻击，掉包怎么办？这个时候公钥就应该交给一个第三方权威机构来管理，这个机构就是认证机构（Certification Authority）CA，CA 把用户的姓名、组织、邮箱地址等个人信息收集起来，还有此人的公钥，并由 CA 提供数字签名生成公钥证书（Public-Key Certificate）PKC，简称证书。

![image](https://user-images.githubusercontent.com/74364990/175810435-955b8d89-9b82-4f64-b307-e94718652322.png)

Alice 向 Bob 发送消息时，是通过 Bob 提供的公钥加密后的数据，而 Alice 获取的公钥并不是由 Bob 直接给的，而是由委托一个受信任的第三方机构给的。

- （1）Bob 生成密钥对，私钥自己保管，公钥交给认证机构 Trent。
- （2）Trent 经过一系列严格的检查确认公钥是 Bob 本人的
- （3）Trent 事先也生成自己的一套密钥对，用自己的私钥对 Bob 的公钥进行数字签名并生成数字证书。证书中包含了 Bob 的公钥。公钥在这里是不需要加密的，因为任何人获取 Bob 的公钥都没事，只要确定是 Bob 的公钥就行。
- （4）Alice 获取 Trent 提供的证书。
- （5）Alice 用 Trent 提供的公钥对证书进行签名验证，签名验证成功就表示证书中的公钥是 Bob 的。
- （6）于是 Alice 就可以用 Bob 提供的公钥对消息加密后发送给 Bob。
- （7）Bob 收到密文后，用与之配对的私钥进行解密。

至此，一套比较完善的数据传输方案就完成了。HTTPS（SSL/TLS）就是在这样一套流程基础之上建立起来的。


## 4、完整流程
HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：

（1）TCP 三次同步握手
（2）客户端验证服务器数字证书
（3）DH 算法协商对称加密算法的密钥、hash 算法的密钥
（4）SSL 安全加密隧道协商完成
（5）网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

![image](https://user-images.githubusercontent.com/74364990/175811715-d71ea4b6-2301-4933-9f42-ef4c8a9561d5.png)


- 客户端向服务端发送 `Client Hello` 消息，其中携带客户端支持的协议版本、加密算法、压缩算法以及客户端生成的随机数；
- 服务端收到客户端支持的协议版本、加密算法等信息后；
  - 向客户端发送 `Server Hello` 消息，并携带选择特定的协议版本、加密方法、会话 ID 以及服务端生成的随机数；
  - 向客户端发送 `Certificate` 消息，即服务端的证书链，其中包含证书支持的域名、发行方和有效期等信息；
  - 向客户端发送 `Server Key Exchange` 消息，传递公钥以及签名等信息；
  - 向客户端发送可选的消息 `Certificate Request`，验证客户端的证书；
  - 向客户端发送 `Server Hello Done` 消息，通知服务端已经发送了全部的相关信息；
- 客户端收到服务端的协议版本、加密方法、会话 ID 以及证书等信息后，验证服务端的证书；
  - 向服务端发送 `Client Key Exchange` 消息，包含使用服务端公钥加密后的随机字符串，即预主密钥（`Pre Master Secret`）；
  - 向服务端发送 `Change Cipher Spec` 消息，通知服务端后面的数据段会加密传输；
  - 向服务端发送 `Finished` 消息，其中包含加密后的握手信息；
- 服务端收到 `Change Cipher Spec` 和 `Finished` 消息后；
  - 向客户端发送 `Change Cipher Spec` 消息，通知客户端后面的数据段会加密传输；
  - 向客户端发送 `Finished` 消息，验证客户端的 `Finished` 消息并完成 TLS 握手；

TLS 握手的关键在于利用通信双发生成的随机字符串和服务端的证书公钥生成一个双方经过协商后的对称密钥，这样通信双方就可以使用这个对称密钥在后续的数据传输中加密消息数据，防止中间人的监听和攻击，保证通讯安全。

>HTTPS连接 需要7次握手，3次TCP + 4次TSL。


# 三、HTTP 与 HTTPS的区别

![image](https://user-images.githubusercontent.com/74364990/174846397-f86ca6c8-cf54-474e-9c71-2b6319a1ad7a.png)


> 参考：https://segmentfault.com/a/1190000023936425
