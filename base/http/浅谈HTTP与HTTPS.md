
# 一、HTTP

- HTTP协议中的数据是利用TCP协议传输的
- HTTP是应用层协议，定义的是传输数据的内容的规范；

<br>

## HTTP报文

- 请求报文：请求行 + 请求头 + 请求体

![image](https://user-images.githubusercontent.com/74364990/110167285-8207a080-7e30-11eb-8b0a-b18974d7fda6.png)

- 响应报文：响应行 + 响应头 + 响应体

![image](https://user-images.githubusercontent.com/74364990/110167294-8633be00-7e30-11eb-9580-6e1ae7b60684.png)

<br>

## 状态码

状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。
状态码如200 OK，以3为数字和原因短语组成。
数字中的第一位定义了响应类别，后两位无分类。响应类别有以下五种：

|     |               类别               |          原因短语          |
|:---:|:--------------------------------:|:--------------------------:|
| 1XX |    Informational(信息性状态码)   |     接收的请求正在处理     |
| 2XX |       Success（成功状态码）      |      请求正常处理完毕      |
| 3XX |    Redirection（重定向状态码）   | 需要进行附加操作以完成请求 |
| 4XX | Client Error（客户端错误状态码） |     服务器无法处理请求     |
| 5XX | Server Error（服务器错误状态码） |     服务器处理请求出错     |

<br>

#### 2XX 成功
 - 200 OK：请求被正常处理
 - 204 No Content：一般在只需从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。
 - 206 Partial Content：客户端进行范围请求

#### 3XX 重定向
 - 301 Moved Permanently：永久重定向。表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。
也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location首部字段提示的URI重新保存。
 - 302 Found：临时性重定向。表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。
和301 Moved Permanently状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。比如，用户把URI保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回302状态码的页面对应的URI（在Chrome中，还是会保存为重定向后的URI，不解）。
 - 303 See Other：表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。这与302类似，但303明确表示客户端应当采用GET方法获取资源。
 - 304 Not Modified：该状态码表示客户端发送附带条件的请求（指采用GET方法的请求报文中包含If-Match,If-Modified-Since，If-None-March，If-Range，If-Unmodified-Since中任一首部。）时，服务器端允许请求访问资源，但因发生请求为满足条件的情况后，直接返回304（服务器端资源未改变，可直接使用客户端未过期的缓存）。304状态码返回时，不包含任何响应的主体部分。  
 304虽被划分在3XX类别，但是和重定向没有关系。
 - 307 Temporary Redirect：临时重定向。与302有相同含义。307遵守浏览器标准，不会从POST变成GET。

> 就算是304，也需要发出请求与接收响应，也会耗费资源和时间。

#### 4XX 客户端错误
4XX的响应结果表明客户端是发生错误的原因所在。

 - 400 Bad Request：表示请求报文中存在语法错误。
 - 401 Unauthorized：表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。
 - 403 Forbidden：表明对请求资源的访问被服务器拒绝了。服务器端可在实体的主体部分对原因进行描述（可选）
 - 404 Not Found：表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时时用。

#### 5XX 服务器错误
5XX的响应结果表明服务器本身发生错误。

 - 500 Interval Server Error：表明服务器端在执行请求时发生了错误。也有可能是Web应用存在的bug或某些临时的故障。
 - 503 Service Unavailable：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入Retry-After首部字段再返回给客户端。

<br>

## 浏览器输入URL后，依次涉及的协议

- DNS 服务：解析域名至对应的IP地址
- HTTP 协议：生成针对目标Web服务器的HTTP请求报文
- TCP 协议：将请求报文按序号分割成多个报文段
- IP 协议：搜索对方的地址，一边中转一边传送
- TCP 协议：按序号以原来的顺序重组请求报文请求的处理结果也同样利用TCP/IP协议向用户进行回传

![image](https://user-images.githubusercontent.com/74364990/110167848-4c16ec00-7e31-11eb-9c91-c7a10a9dcfd7.png)


<br>

# 二、HTTPS

在HTTP的基础上再加一层TLS（传输层安全性协议）或者SSL（安全套接层），就构成了HTTPS协议。

HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：

（1）TCP 三次同步握手<br>
（2）客户端验证服务器数字证书<br>
（3）DH 算法协商对称加密算法的密钥、hash 算法的密钥<br>
（4）SSL 安全加密隧道协商完成<br>
（5）网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

![image](https://user-images.githubusercontent.com/74364990/110168388-16263780-7e32-11eb-8144-d0595e6c98cf.png)

- 客户端向服务端发送 `Client Hello` 消息，其中携带客户端支持的协议版本、加密算法、压缩算法以及客户端生成的随机数；
- 服务端收到客户端支持的协议版本、加密算法等信息后；
  - 向客户端发送 `Server Hello` 消息，并携带选择特定的协议版本、加密方法、会话 ID 以及服务端生成的随机数；
  - 向客户端发送 `Certificate` 消息，即服务端的证书链，其中包含证书支持的域名、发行方和有效期等信息；
  - 向客户端发送 `Server Key Exchange` 消息，传递公钥以及签名等信息；
  - 向客户端发送可选的消息 `Certificate Request`，验证客户端的证书；
  - 向客户端发送 `Server Hello Done` 消息，通知服务端已经发送了全部的相关信息；
- 客户端收到服务端的协议版本、加密方法、会话 ID 以及证书等信息后，验证服务端的证书；
  - 向服务端发送 `Client Key Exchange` 消息，包含使用服务端公钥加密后的随机字符串，即预主密钥（`Pre Master Secret`）；
  - 向服务端发送 `Change Cipher Spec` 消息，通知服务端后面的数据段会加密传输；
  - 向服务端发送 `Finished` 消息，其中包含加密后的握手信息；
- 服务端收到 `Change Cipher Spec` 和 `Finished` 消息后；
  - 向客户端发送 `Change Cipher Spec` 消息，通知客户端后面的数据段会加密传输；
  - 向客户端发送 `Finished` 消息，验证客户端的 `Finished` 消息并完成 TLS 握手；

TLS 握手的关键在于利用通信双发生成的随机字符串和服务端的证书公钥生成一个双方经过协商后的对称密钥，这样通信双方就可以使用这个对称密钥在后续的数据传输中加密消息数据，防止中间人的监听和攻击，保证通讯安全。

>HTTPS连接 需要7次握手，3次TCP + 4次TSL。

<br><br>

## 上面过程看不懂没关系，来个浅显易懂的：

![image](https://user-images.githubusercontent.com/74364990/110170548-53d88f80-7e35-11eb-9850-ce4e3f4a0d69.png)

**1、客户端发起HTTPS请求**
 
 这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。

**2、服务端的配置**

 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。<br>
 这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

**3、传送证书**

 这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。
 
**4、客户端解析证书**

 这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。<br>
 如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。

**5、传送加密信息**

 这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

**6、服务段解密信息**

 服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。
 
**7、传输加密后的信息**

 这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。
 
**8、客户端解密信息**

 客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。

