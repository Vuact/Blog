# 总结
1、浏览器第一次发起一个http/https请求，读取服务器的资源

2、服务端设置响应头（cache-control、Expires、last-modified、Etag）给浏览器

- cache-control、Expires 属于强缓存<br>
- last-modified、Etag属于对比缓存

3、浏览器不关闭tab、f5刷新页面（再次发起一个请求给服务器）

- 如果cache-control的max-age 和 Expires 未超过缓存时间，所有资源除了index.html 都来自于内存缓存（from memory cache）加载。且状态码为200<br>
- 如果cache-control的max-age缓存时间为5s， Expires的过期时间是超过5s，则cache-control会覆盖Expires
- 如果强缓存失效，则下一步会走对比缓存。浏览器会从第二步的拿到的响应头，在刷新发起请求会设置
	- if-modified-since值为响应的last-modified的值；
	- if-none-match 值为响应的Etag的值;
- 如果if-modified-since 和if-none-match都存在，则if-none-match的优先比if-modified-since高。直接对比第二步给浏览器的Etag的值，如果相等就直接返回一个状态为304不返回内容，如果不相等就返回一个状态码为200，并且会返回内容和cache-control 、Expires、last-modified、Etag等响应头；
- 如果if-modified-since 存在， if-none-match不存在，步骤跟上述的3.4类似，只不过服务端对比的是if-modified-since 和第一次返回给浏览器last-modified的值

4、如果浏览器关闭tab。重新打开新tab，发起请求资源。步骤跟上述3类似，只不过在上述3.1中，左右资源除了index.html缓存（from disk cache）都从磁盘加载。

<br>

# http缓存分为 强缓存 和 对比缓存

## 1、强缓存：
当客户端请求后，会先访问缓存数据库看缓存是否存在。如果存在则直接返回，不存在则请求真的服务器。

强制缓存直接减少请求数，是提升最大的缓存策略。 它的优化覆盖了文章开头提到过的请求数据的全部三个步骤。如果考虑使用缓存来优化网页性能的话，强制缓存应该是首先被考虑的。

可以造成强制缓存的字段是 `Cache-control` 和 `Expires`

<br>

### Expires(已废弃)

这是 HTTP 1.0 的字段，表示缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)。在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。

>Expires: Thu, 22 Mar 2029 16:06:42 GMT

```js
const http = require('http')
const url = require('url')
const path = require('path')
const fs = require('fs')

http.createServer((req, res) => {
    let { pathname } = url.parse(req.url, true);
    console.log(pathname)
    let abs = path.join(__dirname, pathname);
    res.setHeader('Expires', new Date(Date.now() + 20000).toGMTString());
    fs.stat(path.join(__dirname, pathname), (err, stat) => {
        if(err) {
            res.statusCode = 404;
            res.end('not found')
            return
        }
        if(stat.isFile()) {
            fs.createReadStream(abs).pipe(res)
        }
    })
}).listen(3000)
```

以上代码给Expires设置过期时间为20s。

（1）首次请求 首次请求 全部走网络请求



（2）20s内F5刷新当前，从内存里面加载。因为我们没有关闭TAB，所以浏览器把缓存的应用加到了内存缓存。（耗时0ms，也就是1ms以内）



（3）20s内关闭tab，打开请求的url，从磁盘加载

关闭了TAB，内存缓存也随之清空。但是磁盘缓存是持久的，于是所有资源来自磁盘缓存。（大约耗时3ms，因为文件有点小）而且对比2和3，很明显看到内存缓存还是比disk cache快得多的。


（4）20s以后请求，缓存已经失效，重复第1步


过期的缺点：

在这里，其他电脑访问服务器，若修改电脑的本地时间，会导致浏览器判断缓存失效 这里修重新修改缓存时间： 

```js
res.setHeader（'Expires', new Date(Date.now() + 2000000).toGMTString())
```

<br>

### Cache-control

已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求

Expires 和 Cache-control 区别：
- Expires设置的是 绝对时间
- Cache-control设置的是 相对时间